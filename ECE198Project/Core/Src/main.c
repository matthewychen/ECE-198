#include "main.h"
#include "stdio.h"
#include <string.h>


ADC_HandleTypeDef hadc1;
UART_HandleTypeDef huart2;

void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_USART2_UART_Init(void);

char uart_buffer[50]; // Buffer for UART messages
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_USART2_UART_Init();

    HAL_ADC_Start(&hadc1); // Start the ADC
    uint32_t runningaverage[50] = {0}; // Initialize running average array
    uint32_t runningaveragesum = 0;    // Sum for running average
    uint32_t trueaverage = 0;          // Final calculated average

    // Fill the running average array initially
    for (uint32_t i = 0; i < 50; i++)
    {
        HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY); // Wait for conversion
        uint32_t adc_value = HAL_ADC_GetValue(&hadc1);    // Get ADC value
        runningaverage[i] = adc_value;                   // Populate array
        runningaveragesum += adc_value;                  // Add to sum
    }

    // Main loop
    while (1)
    {
        HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY); // Wait for conversion
        uint32_t adc_value = HAL_ADC_GetValue(&hadc1);    // Get ADC value

        // Update running average
        runningaveragesum -= runningaverage[0];           // Subtract oldest value
        for (uint32_t i = 0; i < 49; i++)
        {
            runningaverage[i] = runningaverage[i + 1];    // Shift array left
        }
        runningaverage[49] = adc_value;                  // Add new value
        runningaveragesum += adc_value;                  // Add new value to sum

        // Calculate the true average
        trueaverage = runningaveragesum / 50;

        // Set GPIO based on average
        if (trueaverage < 2900)
        {
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);//adc reading indicates moisture is needed
        }
        else
        {
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);//moisture no longer needed
        }

        if (trueaverage <2800){
        		uint8_t *tx_buffer;

        	// Convert integer to byte array
        	HAL_SPI_Transmit(&hspi1, tx_buffer, sizeof(tx_buffer), HAL_MAX_DELAY);
        	HAL_Delay(1000*120);

        }
        HAL_Delay(100); // Delay to avoid flooding the serial monitor
    }
}

static void MX_ADC1_Init(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    hadc1.Instance = ADC1;
    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
    hadc1.Init.Resolution = ADC_RESOLUTION_12B;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.ScanConvMode = DISABLE; // Single-channel mode
    hadc1.Init.ContinuousConvMode = ENABLE; // Enable continuous mode
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc1.Init.DMAContinuousRequests = DISABLE;

    if (HAL_ADC_Init(&hadc1) != HAL_OK)
    {
        Error_Handler();
    }

    sConfig.Channel = ADC_CHANNEL_0;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;

    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
}


static void MX_USART2_UART_Init(void)
{
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 9600; // Standard baud rate for UART
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart2.Init.OverSampling = UART_OVERSAMPLING_16;

    if (HAL_UART_Init(&huart2) != HAL_OK)
    {
        Error_Handler();
    }
}

static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // Enable GPIO clock
    __HAL_RCC_GPIOA_CLK_ENABLE();

    // Configure GPIO Pin 5 as output
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // Push-pull output
    GPIO_InitStruct.Pull = GPIO_NOPULL;        // No pull-up, no pull-down
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; // Low-speed output

    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}


void SystemClock_Config(void)
{
    // Auto-generated by STM32CubeMX for your specific board
}

void Error_Handler(void)
{
    while (1)
    {
        // Stay here if an error occurs
    }
}

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{
    // Report the file name and line number where the assert failed
}
#endif
